{"version":3,"file":"cache.js","names":["prompt: string","llmKey: string","g: string","generations: Generation[]","filter: Record<string, unknown>","collection: Collection<MongoDBDocument>","embeddingModel: EmbeddingsInterface","options: {\n      indexName?: string;\n      scoreThreshold?: number | null;\n      waitUntilReady?: number | null;\n    }","llmString: string","returnVal: Generation[]","text: string","filters: Record<string, unknown>","array: number[]"],"sources":["../src/cache.ts"],"sourcesContent":["import { Collection, Document as MongoDBDocument } from \"mongodb\";\nimport {\n  BaseCache,\n  serializeGeneration,\n  deserializeStoredGeneration,\n} from \"@langchain/core/caches\";\nimport { Generation } from \"@langchain/core/outputs\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\n\nexport interface MongoDBCacheArgs {\n  collection: Collection<MongoDBDocument>;\n}\n\nexport class MongoDBCache extends BaseCache {\n  private collection: Collection<MongoDBDocument>;\n\n  private PROMPT = \"prompt\";\n\n  private LLM = \"llm\";\n\n  private RETURN_VAL = \"return_val\";\n\n  constructor({ collection }: MongoDBCacheArgs) {\n    super();\n    this.collection = collection;\n  }\n\n  async lookup(prompt: string, llmKey: string): Promise<Generation[] | null> {\n    const doc = await this.collection.findOne({\n      [this.PROMPT]: { $eq: prompt },\n      [this.LLM]: { $eq: llmKey },\n    });\n    if (!doc?.[this.RETURN_VAL]) return null;\n    try {\n      const arr = JSON.parse(doc[this.RETURN_VAL]);\n      return arr.map((g: string) => deserializeStoredGeneration(JSON.parse(g)));\n    } catch {\n      return null;\n    }\n  }\n\n  async update(\n    prompt: string,\n    llmKey: string,\n    generations: Generation[]\n  ): Promise<void> {\n    const serialized = JSON.stringify(\n      generations.map((g) => JSON.stringify(serializeGeneration(g)))\n    );\n    await this.collection.updateOne(\n      { [this.PROMPT]: prompt, [this.LLM]: llmKey },\n      { $set: { [this.RETURN_VAL]: serialized } },\n      { upsert: true }\n    );\n  }\n\n  async clear(filter: Record<string, unknown> = {}): Promise<void> {\n    await this.collection.deleteMany(filter);\n  }\n}\n\nexport interface MongoDBAtlasSemanticCacheArgs {\n  collection: Collection<MongoDBDocument>;\n  embeddings: EmbeddingsInterface;\n  indexName?: string;\n  scoreThreshold?: number;\n  waitUntilReady?: number;\n}\n\nexport class MongoDBAtlasSemanticCache extends BaseCache {\n  private collection: Collection<MongoDBDocument>;\n\n  private embeddingModel: EmbeddingsInterface;\n\n  private indexName: string;\n\n  private scoreThreshold: number | null;\n\n  private waitUntilReady: number | null;\n\n  constructor(\n    collection: Collection<MongoDBDocument>,\n    embeddingModel: EmbeddingsInterface,\n    options: {\n      indexName?: string;\n      scoreThreshold?: number | null;\n      waitUntilReady?: number | null;\n    } = {}\n  ) {\n    super();\n    this.collection = collection;\n    this.embeddingModel = embeddingModel;\n    this.indexName = options.indexName ?? \"default\";\n    this.scoreThreshold = options.scoreThreshold ?? null;\n    this.waitUntilReady = options.waitUntilReady ?? null;\n  }\n\n  async lookup(\n    prompt: string,\n    llmString: string\n  ): Promise<Generation[] | null> {\n    const embedding = MongoDBAtlasSemanticCache.fixArrayPrecision(\n      await this.getEmbedding(prompt)\n    );\n    const searchQuery = {\n      queryVector: embedding,\n      index: this.indexName,\n      path: \"embedding\",\n      limit: 1,\n      numCandidates: 20,\n    };\n    const searchResponse = await this.collection\n      .aggregate([\n        { $vectorSearch: searchQuery },\n        { $set: { score: { $meta: \"vectorSearchScore\" } } },\n        {\n          $match: {\n            llm_string: MongoDBAtlasSemanticCache.extractModelName(\n              llmString ?? \"\"\n            ),\n          },\n        },\n        { $limit: 1 },\n      ])\n      .toArray();\n    if (\n      searchResponse.length === 0 ||\n      (this.scoreThreshold !== null &&\n        searchResponse[0].score < this.scoreThreshold)\n    ) {\n      return null;\n    }\n    return searchResponse[0].return_val;\n  }\n\n  async update(\n    prompt: string,\n    llmString: string,\n    returnVal: Generation[]\n  ): Promise<void> {\n    const embedding = await this.getEmbedding(prompt);\n    await this.collection.insertOne({\n      prompt,\n      llm_string: MongoDBAtlasSemanticCache.extractModelName(llmString),\n      return_val: returnVal,\n      embedding,\n    });\n    if (this.waitUntilReady) {\n      await new Promise<void>((resolve) => {\n        setTimeout(resolve, this.waitUntilReady! * 1000);\n      });\n    }\n  }\n\n  async getEmbedding(text: string): Promise<number[]> {\n    return await this.embeddingModel.embedQuery(text);\n  }\n\n  async clear(filters: Record<string, unknown> = {}): Promise<void> {\n    await this.collection.deleteMany(filters);\n  }\n\n  static extractModelName(llmString: string): string {\n    let safeLLMString = \"unknown_model\";\n    const match = llmString.match(\n      /(?:^|,)model_name:\"([^\"]+)\"|(?:^|,)model:\"([^\"]+)\"/\n    );\n    if (match) {\n      safeLLMString = match[1] ?? match[2];\n    }\n    return safeLLMString;\n  }\n\n  static fixArrayPrecision(array: number[]): number[] {\n    if (!Array.isArray(array)) {\n      console.error(\"fixArrayPrecision received an invalid input:\", array);\n      return [];\n    }\n    return array.map((value) =>\n      Number.isInteger(value) ? value + 0.000000000000001 : value\n    );\n  }\n}\n"],"mappings":"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"}